{"Content": "1912年，阿兰·图灵生于英国。少年时代，他就在数学和物理方面展现出极高的天赋。1931年，他考入剑桥大学，在那里，逻辑学家库尔特·哥德尔（Kurt Gödel）的研究吸引了他的兴趣。哥德尔研究的是所有逻辑体系的固有不完整性的一般性问题。三年前，他就构建某种机器的理论可能性发表了一篇论文，这种机器能够运算诸如加法、乘法等不同算法。受哥德尔研究的启发，1937年，图灵将有限的证明和计算向前推动了一步，并构建了“通用机器”的原理，这台机器能够执行所有可能的算法，现代信息理论的支柱之一就此诞生。在此之前的两年，图灵曾与伟大的匈牙利数学家亚诺什·冯·诺依曼（János von Neumann）有过接触，当时冯·诺依曼住在美国，大家都叫他约翰。人们把冯·诺依曼称为“另一位计算机之父”，他给图灵在普林斯顿提供了一份薪水和地位都很高的工作，但图灵拒绝了，他更喜欢剑桥波希米亚式（不拘于传统）的氛围。1939年，战争爆发，他加入位于布莱切利庄园的英国密码分析团队。图灵在战争期间的突出贡献为他赢得了大英帝国勋章，但他是同性恋，这在当时是非法的。1952年图灵被判有罪，无法继续承担政府的保密工作。1954年6月8日，因提起的反诉被驳回而心生绝望，阿兰·图灵吞下氰化钾自杀身亡。", "File": "4c1e91e6fee8e5dc8cb329513f4cb36882d68ab42bab426d43a3681585e3a782_数学家间谍与黑客：密码与解码.epub", "Length": 535}
{"Content": "Apriori算法是一种挖掘频繁项集的经典方法。Apriori算法是一种自底向上逐层搜索的迭代方法，即k-项集用于生成(k+1)-项集，每次迭代过程都需要重新扫描数据集，而且由k-项集进行自连接生成(k+1)-项集时会产生大量的候选项集。也就是说，Apriori算法是一个多趟搜索算法，即最长的频繁项集有多长，Apriori算法就需要扫描多少趟数据集。当面对海量数据集时，Apriori算法的I/O开销很大。Apriori算法最大的性能问题在于对项集及其支持度的计算。假设事务集中包含项目个数为n，Apriori算法需要计算2n个项集，若n很大，将会产生组合爆炸。为了改进Apriori算法，一些研究人员做出了努力：Park等人提出了DHP算法，该算法利用Hash技术对候选项集的生成过程进行了改进；Savasere等人提出了Partition算法，该算法首先对数据集进行分区，然后基于这些分区分别寻找其对应的频繁项集，最后合并得到最终的频繁项集，该算法的整个过程只需要两次数据集扫描；Toivonen等人提出了基于抽样的Sampling算法，该算法也仅通过两次数据集扫描获取频繁项集，首先通过随机数据抽样寻找样本频繁项集，然后再获取全体频繁项集；Brin等人提出了DIC算法对候选项集进行动态计算，该算法与Sampling算法相比，需要计算频繁项集更少，因此，效率也更高。", "File": "ad8431f3aba9d1bcf43db37089a9e0ced2632e151df12b3c27ed02e17fd9accc_并行数据挖掘及性能优化：关联规则.epub", "Length": 587}
{"Content": "虽然上述的Partition算法、Sampling算法和DIC算法等都试图减少对数据集的扫描次数，但仍存在着很多问题。Sampling算法首先从原始数据集中通过随机抽样得到部分样本数据，然后利用样本来寻找频繁项集，但数据集中数据分布不均匀的情况是经常存在的，因此这种随机抽样可能无法保证抽取到的样本具有代表性。Partition算法先对数据集做了分区操作，然后分别挖掘，最后再经过汇总得到最终结果。该方法虽然减轻了I/O负担，但事实上它却增加了CPU负担。DIC算法虽然采用了动态计算的策略，但其与Apriori算法没有本质区别，即DIC算法还属于多趟搜索算法。这些算法在计算过程中会生成大量不必要的候选项集，因此计算量很大。当面对海量数据集时，上述算法的性能问题会更加明显。由此可见，以上算法只有在最小支持度和最小置信度都设置得比较大或增加设置其他一些约束条件后，挖掘效率才会有明显提高，否则候选项集的产生过程将会出现组合爆炸问题。在频繁项集挖掘过程中，必须对所有项集及其支持度进行计数，这也是影响频繁项集挖掘算法效率的关键所在。该类算法每一轮的计算不仅占用大量CPU时间，而且还涉及频繁的I/O操作，因此只有从本质上改变这种自底向上的逐层计算模式，才能从根本上提高算法效率。", "File": "ad8431f3aba9d1bcf43db37089a9e0ced2632e151df12b3c27ed02e17fd9accc_并行数据挖掘及性能优化：关联规则.epub", "Length": 539}
{"Content": "集群和其他无共享多处理器系统是解决上述内存问题的一种可扩展计算平台。例如，Pramudiono和Kitsuregawa提出了一种集群下的并行FP-Growth算法；在无共享多处理器环境下，Javed和Khokhar提出了一种采用消息传递接口实现的高效并行算法，他们提出的基于Pfp-tree的并行算法通过合理地划分FP-tree和处理器上的频繁项目列表，有效地减少了同步开销；Tang和Turkia利用扩展的条件数据集和k-前缀搜索空间划分，提出了基于FP-tree的一种新的实现方法；Yu和Zhou提出了两种并行挖掘算法，即基于Tidset的并行FP-tree（TPFP-tree）挖掘算法和平衡Tidset的并行FP-tree（BTP-tree）挖掘算法，TPFP-tree算法使用事务标识集直接选择事务，而不需要扫描整个数据集。像大多数集群环境下的并行挖掘算法一样，TPFP-tree采用了消息传递接口编程模型。这些并行算法在实现过程中，会暴露出并行计算平台可能存在的一些性能问题，如并行平台存在数据放置问题，任务调度缺乏对异构环境的考虑，节点之间通信量大，异步代价大，计算负载不均衡等。针对这些问题，一些优化策略被提出。", "File": "ad8431f3aba9d1bcf43db37089a9e0ced2632e151df12b3c27ed02e17fd9accc_并行数据挖掘及性能优化：关联规则.epub", "Length": 514}
{"Content": "从图1-3可以看出，一个MapReduce作业（Job）通常会把输入数据集划分为若干个独立的数据分片（Splits），并由Map任务（Map Tasks）以完全并行的方式处理，随后Map任务的输出被分区、排序及合并等一系列中间操作处理后复制至相应的Reduce任务（Reduce Tasks）并执行得到最终结果。MapReduce框架由一个单独的Master JobTracker和每个集群节点的一个Slave TaskTracker组成，JobTracker负责整个作业执行过程中的应用程序的总体协调工作，TaskTracker则具体负责执行作业被划分后的各计算任务。在整个数据处理过程中，JobTracker和TaskTracker之间通过TaskTracker的周期性“心跳”进行通信，整个框架依据该“心跳”负责任务的调度、监控及容错等很多底层的细节处理。由于JobTracker既要负责任务状态的监控又要负责任务的具体调度工作，很容易遭遇单点性能瓶颈。针对该问题，Hadoop 0.23版本对MapReduce进行了优化，其主要思想是将资源管理功能交给另一种资源协调者（Yet Another Resource Negotiator，YARN）来进行管理。YARN将JobTracker的功能进行拆分，通过创建一个全局的ResourceManager（RM）来负责总体的任务调度和创建若干个针对应用程序的ApplicationMaster（AM）来完成具体的作业。", "File": "ad8431f3aba9d1bcf43db37089a9e0ced2632e151df12b3c27ed02e17fd9accc_并行数据挖掘及性能优化：关联规则.epub", "Length": 636}
{"Content": "FIFO调度算法中用户作业都被提交到一个单一的队列中，并按照先进先出的原则进行调度。FIFO算法的实现较为简单、开销相对较小，但FIFO调度算法存在的问题也是显而易见的：当队列中存在大作业时，占用资源时间较短的小作业可能需要花费较长的时间等待，即可能需要较长的响应时间。当面对多用户情况时，这个问题会产生严重的不公平。计算能力调度算法由Yahoo提出，该方法能够支持多个队列进行调度，且在每个队列内部也采用FIFO算法调度。计算能力调度算法支持作业按优先级进行调度，但不能抢占已开始执行作业的资源。在进行作业选择时，每个队列都设置一个权值，即为该队列中的任务数与该队列应分得的计算资源的比值。一旦集群中有计算节点处于空闲状态，调度算法就选择一个权值最低的队列，并按照“先进先出”策略选择其中的一个作业执行。另外，计算能力调度算法在选择作业时，还需考虑作业所属的用户能够使用的计算资源限制，其目的是为了保证用户获取计算资源的公平性。公平调度算法是由Facebook开发的，其将整个集群的计算资源按照“池”来划分，并用“池”来管理作业，每个用户可以获得一个计算资源相对公平的资源池来执行自己的作业。在每个资源池的内部，既可以采用FIFO调度算法进行调度，又可以采用公平调度算法来进行作业调度，还可以在其中加入相应的优先级进行作业调度。", "File": "ad8431f3aba9d1bcf43db37089a9e0ced2632e151df12b3c27ed02e17fd9accc_并行数据挖掘及性能优化：关联规则.epub", "Length": 565}
